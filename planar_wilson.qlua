require "show"

-- Planar_wilson takes in
--            L : A lattice
--           U4 : A gauge field
--  index_space : A choice of an axis   (1-indexed)
--   index_time : A choice of time_axis (1-indexed)
--           nx : A choice of how far to go in the x direction
--           nt : A choice of how far to go in the t direction 
--         file : where to write the results

function planar_wilson(L,U4,index_time,nx,nt,filename)

  --Open file to write to
  local file = io.open(filename,"w")

  --Then, make copies
  local xi = {} -- Holds the indices that are spatial
  local Us = {} -- Holds the copies that get shifted
  local Um = {} -- Holds the copies that get multiplied
  for i=1,#L do
    if i ~= index_time then
      xi[#xi+1] = i
    end 
    Us[i] = L:ColorMatrix(U4[i])
    Um[i] = L:ColorMatrix(U4[i])
  end

  for nx=1,nx do
    print("Calculating nx="..nx)

    --Reset the time gauge
    Us[index_time] = L:ColorMatrix(U4[index_time])
    Um[index_time] = L:ColorMatrix(U4[index_time])
    for nt=1,nt do
      print("Calculating nt="..nt)
     
      --Loop over the spatial indices 
      local ans = {}
      for i=1,#L do
        if i ~= index_time then
          --Get the things we need to shift
          local Ux_s = L:ColorMatrix(Um[i])
          local Ut_s = L:ColorMatrix(Um[index_time])
          for it=1,nt do
            Ux_s = Ux_s:shift(index_time-1,"from_forward")
          end
          for ix=1,nx do
            Ut_s = Ut_s:shift(i-1,"from_forward")
          end
          ans[i] = (Um[i] * 
                    Ut_s *
                    Ux_s:adjoin() * 
                    Um[index_time]:adjoin()):trace():sum()/L:volume()
        end
      end
      local ans_total = complex(0,0)
      for i=1,#L do
        if i ~= index_time then
          ans_total = ans_total + ans[i]
        end
      end
      file:write("nx "..nx.." nt "..nt.." avg "..ans_total:real()/#xi.." "..ans_total:imag()/#xi.."\n")
      Us[index_time] = Us[index_time]:shift(index_time-1,"from_forward")
      Um[index_time] = Um[index_time] * Us[index_time]
      Um[index_time] = Um[index_time]:proj(1e-6,150)
    end
    for i=1,#L do
      if i ~= index_time then
        Us[i] = Us[i]:shift(i-1,"from_forward")
        Um[i] = Um[i]*Us[i]
        Um[i] = Um[i]:proj(1e-6,150)
      end
    end
  end
end 
      
function nonplanar_wilson(L,U4,index_time,nx,nt,filename)

  --Open file to write to
  local file = io.open(filename,"w")

  --Then, make copies
  local xi = {} -- Holds the indices that are spatial
  local Us = {} -- Holds the copies that get shifted
  local Um = {} -- Holds the copies that get multiplied
  for i=1,#L do
    if i ~= index_time then
      xi[#xi+1] = i
    end 
    Us[i] = L:ColorMatrix(U4[i])
    Um[i] = L:ColorMatrix(U4[i])
  end

  for nx=1,nx do
    print("Calculating nx="..nx)

    --Reset the time gauge
    Us[index_time] = L:ColorMatrix(U4[index_time])
    Um[index_time] = L:ColorMatrix(U4[index_time])
    for nt=1,nt do
      print("Calculating nt="..nt)
     
      --Loop over the spatial indices 
      local ans = {}
      for i=1,#L do
        if i ~= index_time then
          --Get the things we need to shift
          local Ux_s = L:ColorMatrix(Um[i])
          local Ut_s = L:ColorMatrix(Um[index_time])
          for it=1,nt do
            Ux_s = Ux_s:shift(index_time-1,"from_forward")
          end
          for ix=1,nx do
            Ut_s = Ut_s:shift(i-1,"from_forward")
          end
          ans[i] = (Um[i] * 
                    Ut_s *
                    Ux_s:adjoin() * 
                    Um[index_time]:adjoin()):trace():sum()/L:volume()
        end
      end
      local ans_total = complex(0,0)
      for i=1,#L do
        if i ~= index_time then
          ans_total = ans_total + ans[i]
        end
      end
      file:write("nx "..nx.." nt "..nt.." avg "..ans_total:real()/#xi.." "..ans_total:imag()/#xi.."\n")
      Us[index_time] = Us[index_time]:shift(index_time-1,"from_forward")
      Um[index_time] = Um[index_time] * Us[index_time]
      Um[index_time] = Um[index_time]:proj(1e-6,150)
    end
    for i=1,#L do
      if i ~= index_time then
        Us[i] = Us[i]:shift(i-1,"from_forward")
        Um[i] = Um[i]*Us[i]
        Um[i] = Um[i]:proj(1e-6,150)
      end
    end
  end
end 
       
       

